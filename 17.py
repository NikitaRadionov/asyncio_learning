import asyncio
import aiohttp
from aiohttp import ClientSession
from util import async_timed


# Итак gather использовать проблематично. Но у asyncio есть решения на два недостатка функции gather
# Напомним недостатки:
# Как мы отмечали, первый недостаток asyncio.gather заключается в том, что нам не так просто отменить заданные задачи, если одна из них возбудила исключение.
# Если нам нужно отменить все запросы на сервер, если хотя бы один из них вызвал исключение, то использование gather не целесообразно.
# Второй недостаток gather заключается в том, что мы должны дождаться завершения всех сопрограмм, прежде чем можно будет приступить к обработке результатов.
# Если мы хотим обрабатывать результаты по мере поступления, то возникает проблема.


# Разрешение недостатков:
# Обработка результатов по мере поступления:
# asyncio.as_completed. Она принимает список Awaitable объектов и возвращает итератор по будущим объектам.
# Будущие объекты можно перебирать применяя к каждому await. Когда await вернет управление, мы получим результат первой завершившейся сопрограммы.
# Это означает, что мы сможем обрабатывать результаты по мере их доступности, но теперь порядок результатов не детерминирован, посколько неизвестно какой объект завершится первым.\

async def fetch_status(session: ClientSession, url: str, delay: int):
    await asyncio.sleep(delay)
    async with session.get(url) as result:
        return result.status

@async_timed()
async def main():
    async with aiohttp.ClientSession() as session:
        fetchers = [
            fetch_status(session, 'https://www.example.com', 1),
            fetch_status(session, 'https://www.example.com', 1),
            fetch_status(session, 'https://www.example.com', 10)
        ]
        for finished_task in asyncio.as_completed(fetchers):
            print(await finished_task)

asyncio.run(main())

# Здесь мы создаем три сопрограммы – две из них завершаются примерно через 1 с, а третья через 10 с. Эти сопрограммы передаются
# функции as_completed. Под капотом каждая сопрограмма обертывается задачей и начинает выполняться конкурентно. Функция немедленно возвращает итератор, который мы начинаем обходить. Войдя
# в  цикл for, мы сразу натыкаемся на await finished_task. Здесь выполнение приостанавливается до момента поступления первого результата
#  В данном случае первый результат поступит через 1 с, и мы напечатаем код состояния. Затем снова дойдем до await finished_task
# и, так как запросы выполняются конкурентно, второй результат станет доступен почти мгновенно. Наконец, через 10 с  завершится
# третий запрос, а вместе с ним и цикл.
# Эта функция также дает больше контроля над обработкой исключений. Если задача возбудит исключение, то мы сможем обработать ее
# сразу же, поскольку оно возникает в точке, где мы ожидаем будущего
# объекта с помощью await.

# Также функция as_completed даёт больше контроля над обработкой исключений, решая тем самым первый недостаток gather.
# Если задача возбудит исключение, то мы сможем обработать ее сразу же, поскольку оно возникает в точке, где мы ожидаем будущего объекта с помощью await.
