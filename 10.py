import asyncio
from asyncio import Future


# Упражнение на работу с Future объектами.
# Создадим эмитацию веб-запроса на веб-сервер.
# Стоит оговорить тот момент, что этот пример по своей сути работает не асинхронно, но такой вид работы с объектами Future, в дальнейшем приведет к асинхронности, если например, таких
# условных задач мы сделаем несколько.
#
# Future объекты используются очень редко, но вполне вероятна ситуация, когда возникнет ситуация, в которой нам будет необходимо уметь с ними работать.
# Поэтому на данном этапе, объекты класса Future стоит понимать на уровне того, что в них должен быть помещен какой-то результат с течением времени.


def make_request() -> Future:
    future = Future()
    asyncio.create_task(set_future_value(future)) # Создать задачу, которая асинхронно установит значение future
    return future


async def set_future_value(future) -> None:
    await asyncio.sleep(1) # ждать 1 с, прежде чем установить значение future. Эмитация ожидания получения ответа от сервера.
    future.set_result(42)


async def main():
    future = make_request() # Получаем объект класса Future
    print(f"Будущий объект готов ? {future.done()}")
    value = await future # Приостановить main пока значение future не установлено. Мы будем ждать до тех пор, пока корутина set_future_value не завершит своё действие
    print(f"Будущий объект готов ? {future.done()}")
    print(value)

asyncio.run(main())

# Также нужно знать, что объекты Future являются Awaitable (допускающими ожидание). Все объекты, которые можно использоваться в выражениях с await, являются Awaitable объектами.
# Почему в выражениях с await мы можем использовать и корутины и задачи и будущие объекты ?
# Все дело в иерархии классов:
# Awaitable -> Future -> Task
#           -> Coroutine
# Задачи наследуются от будущих объектов, будущие объекты наследуются от объектов, допускающих ожидание. Сопрограммы просто наследуются от Awaitable